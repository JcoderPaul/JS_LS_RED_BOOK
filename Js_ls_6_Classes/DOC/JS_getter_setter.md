### Геттеры и сеттеры в JavaScript

Геттеры и сеттеры — это специальные методы в JavaScript, которые позволяют контролировать доступ к свойствам объекта, обеспечивая инкапсуляцию и возможность добавления логики при чтении или записи значений. Они делают свойства объектов более управляемыми, позволяя перехватывать обращения к ним.

#### Описание:

- **Геттер** (`get`) — метод, который вызывается при чтении свойства объекта. Он возвращает значение свойства, возможно, с дополнительной логикой.
- **Сеттер** (`set`) — метод, который вызывается при присваивании значения свойству. Он позволяет валидировать или модифицировать значение перед его сохранением.

Геттеры и сеттеры используются для:
- Контроля доступа к данным.
- Выполнения побочных эффектов при чтении/записи свойства.
- Создания вычисляемых свойств, которые не хранятся напрямую.

#### Как работают:

1. **Синтаксис**:
   - Геттеры и сеттеры определяются с помощью ключевых слов `get` и `set` в объектах или классах.
   - Они выглядят как обычные свойства при обращении, но на самом деле вызывают функции.

2. **В объектах**:
   - Геттеры и сеттеры можно определить в объектном литерале или с помощью `Object.defineProperty`.
   - Пример с объектным литералом:

     ```javascript
     const person = {
         _name: "John",
         get name() {
             return this._name.toUpperCase();
         },
         set name(value) {
             if (typeof value === "string" && value.length > 0) {
                 this._name = value;
             } else {
                 console.error("Invalid name");
             }
         }
     };

     console.log(person.name); // "JOHN"
     person.name = "Alice"; // Устанавливаем новое значение

     console.log(person.name); // "ALICE"
     person.name = ""; // Ошибка: Invalid name
     ```

   - Пример с `Object.defineProperty`:

     ```javascript
     const obj = {};
     let value = 10;
     Object.defineProperty(obj, "value", {
         get() {
             return value * 2;
         },
         set(newValue) {
             value = newValue;
         }
     });

     console.log(obj.value); // 20

     obj.value = 5;
     console.log(obj.value); // 10
     ```

3. **В классах**:
   - Геттеры и сеттеры часто используются в классах для управления свойствами экземпляров.
   - Пример:

     ```javascript
     class Person {
         constructor(name) {
             this._name = name; // Префикс _ для внутреннего свойства
         }
         get name() {
             return this._name.toUpperCase();
         }
         set name(value) {
             if (typeof value === "string" && value.length > 0) {
                 this._name = value;
             } else {
                 throw new Error("Invalid name");
             }
         }
     }
     const person = new Person("John");
     console.log(person.name); // "JOHN"

     person.name = "Alice"; // Устанавливаем новое значение
     console.log(person.name); // "ALICE"
     // person.name = ""; // Ошибка: Invalid name
     ```

#### Похожий функционал:

1. **Методы объекта**:
   - Вместо геттеров и сеттеров можно использовать обычные методы, такие как `getName()` и `setName(value)`, но это менее удобно, так как требует вызова функции явно.
   - Пример:

     ```javascript
     const person = {
         _name: "John",
         getName() {
             return this._name;
         },
         setName(value) {
             this._name = value;
         }
     };

     person.setName("Alice");
     console.log(person.getName()); // "Alice"
     ```

2. **Object.defineProperty / Object.defineProperties**:
   - Эти методы позволяют задавать геттеры и сеттеры для существующих объектов, а также контролировать другие атрибуты свойств (например, `enumerable`, `configurable`).

3. **Proxy**:
   - Объект `Proxy` предоставляет более мощный способ перехвата операций чтения и записи свойств, включая геттеры и сеттеры.
   - Пример:

     ```javascript
     let target = { _name: "John" };

     const proxy = new Proxy(target, {
         get(target, prop) {
             if (prop === "name") {
                 return target._name.toUpperCase();
             }
             return target[prop];
         },
         set(target, prop, value) {
             if (prop === "name" && typeof value === "string" && value.length > 0) {
                 target._name = value;
                 return true;
             }
             console.error("Invalid name");
             return false;
         }
     });

     console.log(proxy.name); // "JOHN"
     proxy.name = "Alice"; // Устанавливаем новое значение

     console.log(proxy.name); // "ALICE"
     proxy.name = ""; // Ошибка: Invalid name
     ```

#### Особенности:

1. **Именование**:
   - Свойства с геттерами и сеттерами обычно используют префикс `_` для внутреннего хранения данных (например, `_name`), чтобы избежать конфликтов с самим свойством.
   - Название геттера/сеттера должно совпадать с именем свойства (например, `get name` для свойства `name`).

2. **Отсутствие хранения**:
   - Геттеры могут создавать вычисляемые свойства, которые не хранятся в объекте, а вычисляются на лету.
   - Пример:

     ```javascript
     const circle = {
         radius: 5,
         get diameter() {
             return this.radius * 2;
         }
     };
     console.log(circle.diameter); // 10

     circle.radius = 10;
     console.log(circle.diameter); // 20
     ```

3. **Ограничения**:
   - Нельзя определить геттер без сеттера или наоборот для одного свойства, если вы хотите, чтобы свойство было доступно только для чтения или записи. Для этого можно использовать `Object.defineProperty` с атрибутами `writable` или `configurable`.
   - Геттеры и сеттеры не могут быть асинхронными (используйте обычные методы для асинхронной логики).

4. **Производительность**:
   - Геттеры и сеттеры немного медленнее, чем прямой доступ к свойствам, из-за вызова функций. Однако современные движки JavaScript оптимизируют этот процесс.

#### Best Practices:

1. **Используйте для инкапсуляции**:
   - Геттеры и сеттеры помогают скрыть внутреннюю реализацию объекта, предоставляя контролируемый интерфейс для доступа к данным.
   - Пример: используйте `_name` для хранения и `name` для публичного доступа.

2. **Валидируйте данные в сеттерах**:
   - Проверяйте входные данные в сеттерах, чтобы предотвратить некорректные значения.
   - Пример:

     ```javascript
     set age(value) {
         if (typeof value === "number" && value >= 0) {
             this._age = value;
         } else {
             throw new Error("Age must be a positive number");
         }
     }
     ```

3. **Избегайте сложной логики в геттерах**:
   - Геттеры должны быть быстрыми и предсказуемыми, так как они выглядят как свойства. Сложные вычисления лучше выносить в методы.

4. **Используйте для вычисляемых свойств**:
   - Геттеры идеальны для свойств, которые зависят от других данных, например, `area` круга на основе `radius`.

5. **Не злоупотребляйте**:
   - Не используйте геттеры и сеттеры для каждого свойства, если нет необходимости в дополнительной логике. Простые свойства быстрее и проще для понимания.

6. **Совместимость с классами**:
   - В классах геттеры и сеттеры делают код более читаемым, чем методы `getX`/`setX`. Используйте их, если работаете с классами.

7. **Избегайте побочных эффектов**:
   - Геттеры не должны изменять состояние объекта, так как это может привести к неожиданному поведению.
   - Плохой пример:

     ```javascript
     get counter() {
         this._counter++; // Побочный эффект
         return this._counter;
     }
     ```

8. **Документируйте**:
   - Если геттеры или сеттеры содержат сложную логику, документируйте их поведение, чтобы другие разработчики понимали, как они работают.

#### Заключение:

Геттеры и сеттеры в JavaScript — это мощный инструмент для управления доступом к свойствам, обеспечения инкапсуляции и создания вычисляемых свойств. Они особенно полезны в классах и при работе с объектами, где требуется контроль или дополнительная логика. Однако их следует использовать с умом, избегая ненужной сложности и побочных эффектов.