Параметрический полиморфизм в JavaScript — это способность функции или типа работать с данными любого типа без привязки к конкретному типу, при этом сохраняя типобезопасность (в контексте JavaScript это достигается за счёт его динамической природы). 

Этот вид полиморфизма часто ассоциируется с обобщённым программированием (generics), где функция или структура данных может быть параметризована типом, который определяется во время использования.

В JavaScript, из-за отсутствия строгой системы типов в стандартном языке, параметрический полиморфизм реализуется неявно благодаря динамической типизации. 

Однако в TypeScript, который расширяет JavaScript, параметрический полиморфизм поддерживается явно через generics.

### Параметрический полиморфизм в стандартном JavaScript:

В JavaScript параметрический полиморфизм достигается за счёт того, что функции не привязаны к конкретным типам данных. Например, функции, работающие с массивами или объектами, могут обрабатывать элементы любого типа, если логика функции не зависит от их конкретного типа.

#### Пример: Универсальная функция для работы с массивами

```javascript
function firstElement(arr) {
    return arr.length > 0 ? arr[0] : null;
}

console.log(firstElement([1, 2, 3])); // 1
console.log(firstElement(["a", "b", "c"])); // "a"
console.log(firstElement([{ id: 1 }, { id: 2 }])); // { id: 1 }
```

Здесь функция `firstElement` работает с массивом любого типа (числа, строки, объекты и т.д.), что является примером параметрического полиморфизма. Она не зависит от типа элементов массива, а только от структуры (массив).

#### Пример: Универсальная функция обмена значениями

```javascript
function swap(pair) {
    return [pair[1], pair[0]];
}

console.log(swap([1, "hello"])); // ["hello", 1]
console.log(swap([true, 42])); // [42, true]
console.log(swap([{ id: 1 }, "world"])); // ["world", { id: 1 }]
```

Функция `swap` работает с любыми типами данных, не требуя их спецификации, что демонстрирует неявный параметрический полиморфизм.

### Параметрический полиморфизм в TypeScript:

TypeScript добавляет явную поддержку параметрического полиморфизма через **generics**, позволяя задавать типы параметров во время вызова функции или создания объекта. Это делает код более строгим и типобезопасным.

#### Пример: Функция с generics

```typescript
function identity<T>(value: T): T {
    return value;
}

console.log(identity<number>(42)); // 42
console.log(identity<string>("hello")); // "hello"
console.log(identity<boolean>(true)); // true
```

Здесь `T` — это параметр типа, который заменяется конкретным типом при вызове функции. Это позволяет функции `identity` работать с любым типом, сохраняя информацию о типе возвращаемого значения.

#### Пример: Универсальная структура данных

```typescript
class Box<T> {
    private content: T;

    constructor(value: T) {
        this.content = value;
    }

    getContent(): T {
        return this.content;
    }
}

const numberBox = new Box<number>(123);
console.log(numberBox.getContent()); // 123

const stringBox = new Box<string>("hello");
console.log(stringBox.getContent()); // "hello"
```

Класс `Box` использует параметр типа `T`, что позволяет создавать экземпляры для хранения данных любого типа, сохраняя типобезопасность.

#### Пример: Ограничения на типы (constrained generics)

```typescript
function getLength<T extends { length: number }>(item: T): number {
    return item.length;
}

console.log(getLength("hello")); // 5
console.log(getLength([1, 2, 3])); // 3
// console.log(getLength(42)); // Ошибка: число не имеет свойства length
```

Здесь тип `T` ограничен объектами, у которых есть свойство `length`, что позволяет функции `getLength` работать с любыми типами, имеющими это свойство (например, строки или массивы).

### Особенности параметрического полиморфизма в JS/TS
1. **В JavaScript**:
   - Параметрический полиморфизм неявный из-за динамической типизации.
   - Нет необходимости явно указывать типы, но это может привести к ошибкам, если функция неожиданно получит неподходящие данные.
   - Подходит для простых случаев, где типы не критичны.

2. **В TypeScript**:
   - Явная поддержка через generics, что улучшает читаемость и типобезопасность.
   - Позволяет создавать более сложные и безопасные конструкции, такие как обобщённые классы, интерфейсы и функции.
   - Ограничения типов (constraints) позволяют задавать требования к типам, делая код более предсказуемым.

### Когда использовать параметрический полиморфизм:

- Когда функция или структура данных должна работать с любым типом данных, но сохранять консистентность в обработке.
- Когда нужно написать переиспользуемый код, который не зависит от конкретного типа (например, утилитарные функции, контейнеры данных).
- В TypeScript — для создания типобезопасных API или библиотек.

### Сравнение с ад-хок полиморфизмом:

- **Ад-хок полиморфизм**: Функция обрабатывает разные типы данных с разной логикой (например, через условные операторы или перегрузку).
- **Параметрический полиморфизм**: Функция работает одинаково для всех типов, не завися от их внутренней структуры (например, функции для работы с массивами или обобщённые классы).

### Пример в typescript:

Если вам нужно написать функцию, которая обрабатывает списки разных типов, но не заботится о том, что внутри, это параметрический полиморфизм:

```typescript
function mapItems<T, U>(items: T[], transform: (item: T) => U): U[] {
    return items.map(transform);
}

const numbers = [1, 2, 3];
const strings = mapItems(numbers, x => x.toString()); // ["1", "2", "3"]
const doubled = mapItems(numbers, x => x * 2); // [2, 4, 6]
```
