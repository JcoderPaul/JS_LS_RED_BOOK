**Callback Queue** (также известная как **Task Queue** или **Очередь задач**) — это компонент механизма асинхронности в JavaScript, используемый для хранения **макрозадач** (macrotasks), которые ждут выполнения после завершения синхронного кода и микрозадач. 

**Очередь макрозадач** играет важную роль в работе **Event Loop** и взаимодействует с другими частями среды выполнения JavaScript (браузер или Node.js).

### Что такое Callback Queue:

- Callback Queue — это очередь для **макрозадач**, таких как коллбэки от асинхронных операций, например:
  - Таймеры: `setTimeout`, `setInterval`.
  - События DOM: клики мыши, нажатия клавиш и т.д.
  - Сетевые запросы: коллбэки от AJAX или `fetch` (в некоторых случаях).
  - Операции ввода-вывода (в Node.js): чтение/запись файлов, сетевые операции.
- Задачи в этой очереди обрабатываются по принципу **FIFO** (First In, First Out): первая добавленная задача выполняется первой.
- Callback Queue отличается от **Microtask Queue**, которая имеет более высокий приоритет и предназначена для микрозадач (например, промисов).

### Как работает Callback Queue:

1. **Добавление задач**:
   - Когда асинхронная операция завершается (например, истекает таймер `setTimeout` или завершается HTTP-запрос), её коллбэк помещается в Callback Queue.
   - Это происходит через среду выполнения (Web APIs в браузере или libuv в Node.js).

2. **Обработка Event Loop**:
   - **Event Loop** постоянно проверяет, пуст ли **Call Stack** (стек вызовов, где выполняется синхронный код).
   - Если Call Stack пуст, Event Loop сначала обрабатывает **все микрозадачи** из **Microtask Queue**.
   - После полного опустошения Microtask Queue Event Loop берёт **одну задачу** из Callback Queue (Task Queue) и помещает её в Call Stack для выполнения.
   - Затем цикл повторяется: проверка Call Stack, обработка микрозадач, выполнение следующей макрозадачи.

3. **Приоритет**:
   - Callback Queue имеет **более низкий приоритет**, чем Microtask Queue. Это значит, что задачи из Callback Queue выполняются только после того, как все микрозадачи завершены.

### Пример работы:

```javascript
console.log('Синхронный код 1');

setTimeout(() => console.log('Макрозадача (setTimeout)'), 0);

Promise.resolve().then(() => console.log('Микрозадача (Promise)'));

console.log('Синхронный код 2');
```
**Вывод**:
```
Синхронный код 1
Синхронный код 2
Микрозадача (Promise)
Макрозадача (setTimeout)
```
**Объяснение**:
1. `Синхронный код 1` и `Синхронный код 2` выполняются сразу в Call Stack.
2. `setTimeout` регистрируется в Web APIs, и его коллбэк добавляется в **Callback Queue** (Task Queue) после задержки 0 мс.
3. Промис добавляет свой коллбэк в **Microtask Queue**.
4. После освобождения Call Stack Event Loop сначала выполняет микрозадачу (`Микрозадача (Promise)`).
5. Затем выполняется макрозадача из Callback Queue (`Макрозадача (setTimeout)`).

### Особенности Callback Queue:

1. **Макрозадачи**:
   - Callback Queue предназначена для макрозадач, которые связаны с асинхронными операциями, делегируемыми в среду выполнения.
   - Примеры: коллбэки от `setTimeout`, `setInterval`, обработчики событий (`onclick`, `onload`), I/O-операции в Node.js.

2. **Обработка по одной задаче**:
   - В отличие от Microtask Queue, где все задачи выполняются за один цикл Event Loop, из Callback Queue за один цикл берётся **только одна макрозадача**. После её выполнения Event Loop снова проверяет Microtask Queue, прежде чем взять следующую макрозадачу.

3. **Задержка выполнения**:
   - Макрозадачи могут быть отложены, если Microtask Queue постоянно пополняется (например, через рекурсивные `.then()` в промисах). Это называется **"голодание" макрозадач** (starvation).

4. **Где находится**:
   - Callback Queue реализована на уровне среды выполнения:
     - В **браузере**: это часть JavaScript-движка (например, V8 в Chrome), взаимодействующая с Web APIs.
     - В **Node.js**: часть библиотеки **libuv**, которая управляет асинхронными операциями и фазами Event Loop (например, `timers`, `poll`, `check`).

5. **Различия между браузером и Node.js**:
   - В браузере Callback Queue обрабатывает задачи, связанные с DOM, таймерами и сетевыми запросами.
   - В Node.js Event Loop разделён на фазы (например, `timers` для `setTimeout`, `poll` для I/O), и каждая фаза имеет свою очередь задач, что делает механизм более сложным, но схожим по сути.

### Пример с несколькими макрозадачами:

```javascript
console.log('Синхронный код');

setTimeout(() => console.log('Макрозадача 1'), 0);
setTimeout(() => console.log('Макрозадача 2'), 0);

Promise.resolve().then(() => console.log('Микрозадача'));

setTimeout(() => console.log('Макрозадача 3'), 0);
```
**Вывод**:
```
Синхронный код
Микрозадача
Макрозадача 1
Макрозадача 2
Макрозадача 3
```
**Объяснение**:
- Синхронный код выполняется первым.
- Микрозадача из промиса выполняется сразу после синхронного кода.
- Макрозадачи из `setTimeout` выполняются по очереди, так как они добавлены в Callback Queue в порядке `Макрозадача 1`, `Макрозадача 2`, `Макрозадача 3`.

### Проблемы и ограничения:

1. **Задержка из-за микрозадач**:
   - Если Microtask Queue постоянно пополняется (например, через рекурсивные промисы), макрозадачи в Callback Queue могут ждать долго.
   - Пример:

     ```javascript
     Promise.resolve().then(function resolve() {
       console.log('Микрозадача');
       Promise.resolve().then(resolve); // Рекурсия
     });
     setTimeout(() => console.log('Макрозадача'), 0);
     ```
     Здесь `Макрозадача` может никогда не выполниться из-за бесконечного добавления микрозадач.

2. **Непредсказуемое время выполнения**:
   - Даже с `setTimeout(..., 0)`, время выполнения макрозадачи зависит от состояния Call Stack и Microtask Queue, а не только от указанной задержки.

3. **Отладка**:
   - Порядок выполнения задач в Callback Queue может быть неочевидным, особенно при сложных асинхронных операциях.

### Заключение:

Callback Queue (Task Queue) — это очередь для макрозадач, которые выполняются после синхронного кода и всех микрозадач из Microtask Queue. Она управляется Event Loop и реализована на уровне среды выполнения (браузер или Node.js). Понимание работы Callback Queue важно для управления асинхронными операциями, такими как таймеры, события или I/O, и для избежания проблем, связанных с приоритетами задач и возможным "голоданием" макрозадач.