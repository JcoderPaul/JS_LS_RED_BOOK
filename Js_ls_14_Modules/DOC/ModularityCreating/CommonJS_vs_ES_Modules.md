### Ключевые отличия CommonJS от ES Modules

CommonJS (CJS) и ES Modules (ESM) — это две системы модулей в JavaScript, используемые для организации кода. CommonJS изначально разработан для Node.js, а ES Modules — стандарт ECMAScript (ES6+), поддерживаемый в браузерах и Node.js. Вот их основные отличия:

| **Характеристика**         | **CommonJS**                                                                 | **ES Modules**                                                                |
|----------------------------|------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| **Синтаксис**              | `require()` для импорта, `module.exports`/`exports` для экспорта.            | `import` для импорта, `export`/`export default` для экспорта.                 |
| **Загрузка**               | Синхронная: модули загружаются немедленно, блокируя выполнение.              | Асинхронная в браузерах, синхронная в Node.js (для совместимости). Поддерживает динамический `import()`. |
| **Tree-shaking**           | Не поддерживает: весь модуль включается в сборку.                            | Поддерживает: бандлеры (Webpack, Rollup) удаляют неиспользуемый код.          |
| **Статичность**            | Динамическая: `require` и `exports` можно вызывать в любом месте (условия, циклы). | Статическая: `import`/`export` только на верхнем уровне, что помогает анализу зависимостей. |
| **Браузеры**               | Не работает нативно, требует бандлеров (Webpack, Rollup) для преобразования. | Работает нативно с `<script type="module">`.                           |
| **Scope**                  | Локальный scope модуля, переменные приватны, если не экспортированы.         | Локальный scope, экспортированные значения — read-only с live bindings (изменения отражаются). |
| **Кэширование**            | Модули кэшируются (singleton), повторный `require` возвращает тот же объект. | Модули кэшируются (singleton), повторный `import` использует тот же экземпляр. |
| **Strict mode**            | Не включает `"use strict"` автоматически, нужно добавлять вручную.           | Автоматически работает в `"use strict"`, предотвращая неявные глобальные переменные. |
| **Пути**                   | Не требует расширений файлов (например, `require('./math')`).                | Требует явных расширений в Node.js (например, `import './math.js'`).          |
| **Совместимость**          | Стандарт для Node.js, широко используется в npm-пакетах и legacy-коде.       | Стандарт ECMAScript, поддерживается в браузерах и Node.js (12+).              |
| **Динамическая загрузка**  | Через `require` в любом месте кода, но синхронно.                           | Через `import()`, возвращает Promise, подходит для lazy loading.              |
| **Метаданные**             | Нет эквивалента `import.meta`.                                              | Поддерживает `import.meta` (например, `import.meta.url` для пути модуля).     |
| **Экспорт**                | Один объект (`module.exports`), можно перезаписать.                         | Именованные (`export`) и дефолтные (`export default`) экспорты, более гибкие. |
| **Совместимость CJS/ESM**  | Может импортировать ESM в Node.js через `require('esm')` или транспиляцию.   | Может импортировать CJS через `default` (например, `import _ from 'lodash'`). |

#### Примеры для сравнения:

**CommonJS:**

```javascript
// math.js
module.exports = {
  add: (a, b) => a + b
};

// app.js
const { add } = require('./math');
console.log(add(2, 3)); // 5
```

**ES Modules:**

```javascript
// math.js
export const add = (a, b) => a + b;

// app.js
import { add } from './math.js';
console.log(add(2, 3)); // 5
```
*Node.js: Для ESM нужен `"type": "module"` в `package.json` или расширение `.mjs`.*

#### Когда выбирать:

- **CommonJS:**
  - Legacy-проекты или Node.js без ESM.
  - Простые серверные скрипты, где важна синхронность.
  - Работа с npm-пакетами, использующими CJS.
- **ES Modules:**
  - Новые проекты, особенно для веба.
  - Когда нужен tree-shaking или асинхронная загрузка.
  - Совместимость с браузерами и стандартизация.

#### Совместимость и миграция:

- **CJS → ESM:** Используйте `import` для CJS-модулей (например, `import pkg from 'pkg'`), но указывайте `"type": "module"`. Для обратной совместимости применяйте Babel или `require('esm')`.
- **ESM → CJS:** Импортируйте ESM через динамический `import()` или транспиляцию. В Node.js CJS не может напрямую `require` ESM без дополнительных инструментов.
- **Бандлеры:** Webpack, Rollup и Vite обрабатывают оба формата, конвертируя их в совместимый код.

#### Итог:

- **CommonJS** — синхронный, простой, но устаревший формат, подходящий для Node.js и legacy-кода.
- **ES Modules** — современный, асинхронный стандарт с поддержкой tree-shaking, нативной работой в браузерах и лучшей оптимизацией. Для новых проектов выбирайте ESM, но учитывайте совместимость с CJS в экосистеме Node.js.