### CommonJS в JavaScript

CommonJS (CJS) — это система модулей, изначально разработанная для серверного JavaScript (Node.js), но также используемая в некоторых браузерных окружениях с бандлерами. 

Она позволяет организовывать код в модули, экспортировать и импортировать функциональность между файлами, обеспечивая изоляцию и переиспользуемость. 

CommonJS является синхронной системой, в отличие от ES Modules (ESM), и остается популярной в Node.js для серверных приложений.

#### Когда применяется:

CommonJS используется, когда:
- Вы работаете в Node.js, особенно в проектах, где не настроены ES Modules (до Node.js 12 ESM не был стандартом).
- Нужна синхронная загрузка модулей, например, для серверных скриптов, где асинхронность менее критична.
- Проект использует устаревший код или библиотеки, написанные под CommonJS (например, многие npm-пакеты).
- Вы хотите простую модульную систему без настройки `type: "module"` в `package.json` или `.mjs`.
- Не требуется tree-shaking (удаление неиспользуемого кода), так как CJS его не поддерживает.

CommonJS менее подходит для браузеров, где предпочтительнее ESM из-за асинхронности и оптимизаций (например, tree-shaking в Webpack). Также в новых проектах рекомендуется ESM для стандартизации и лучшей совместимости с современными инструментами.

#### Как применяется:

CommonJS использует `module.exports` (или `exports`) для экспорта и `require()` для импорта. Каждый файл — это модуль, имеющий собственную область видимости.

- **Экспорт:** Модуль экспортирует данные через `module.exports` (объект, функция, значение) или `exports` (алиас для `module.exports`).
- **Импорт:** `require(path)` синхронно загружает модуль и возвращает его экспортированный объект.
- **Пути:** Указываются относительные (`./file.js`), абсолютные или имена npm-модулей (`require('lodash')`).
- **Кэширование:** Модули кэшируются после первой загрузки, повторные `require()` возвращают тот же объект.

#### Примеры:

**Пример экспорта и импорта (utils.js):**

```javascript
// utils.js
const version = '1.0.0';
function logMessage(message) {
  console.log(`[Log]: ${message}`);
}

// Экспорт нескольких значений
module.exports = {
  version,
  logMessage
};

// Альтернативный синтаксис
// exports.version = version;
// exports.logMessage = logMessage;
```

**Импорт в другом файле (app.js):**

```javascript
// app.js
const utils = require('./utils'); // Без .js, если расширение опущено

console.log(utils.version); // '1.0.0'
utils.logMessage('Hello, CommonJS!'); // [Log]: Hello, CommonJS!
```

**Экспорт одной функции (math.js):**

```javascript
// math.js
module.exports = function add(a, b) {
  return a + b;
};
```

**Импорт и использование:**

```javascript
// main.js
const add = require('./math');

console.log(add(2, 3)); // 5
```

**Работа с npm-модулями:**

```javascript
const _ = require('lodash'); // Импорт библиотеки lodash
console.log(_.capitalize('hello')); // 'Hello'
```

#### Особенности:

- **Синхронность:** `require()` выполняется синхронно, что удобно для сервера, но может замедлить загрузку в браузере.
- **Кэширование:** Модуль загружается и выполняется один раз, последующие `require()` используют кэш. Это создает singleton-поведение.
- **Динамичность:** Экспорты и импорты могут быть динамическими, например, `module.exports[someKey] = value` или `require(somePath)`.
- **Scope:** Переменные в модуле локальны, если не экспортированы. Нет загрязнения глобального пространства.
- **Совместимость:** CommonJS работает в Node.js из коробки, но в браузерах требует бандлеров (Webpack, Rollup) для преобразования в совместимый код.
- **Ограничения:** Не поддерживает tree-shaking, так как импорты не статичны. Не работает в браузерах без сборки, в отличие от ESM.
- **Переопределение exports:** `exports` — это ссылка на `module.exports`. Если перезаписать `exports = something`, связь с `module.exports` теряется, и модуль ничего не экспортирует.

#### Best practices:

- **Используйте `module.exports`:** Предпочитайте `module.exports` вместо `exports` для ясности и избежания ошибок с перезаписью.
- **Не смешивайте CJS и ESM:** Если проект использует CommonJS, избегайте импорта ESM-модулей без специальной настройки (например, `import()` или `esm`-пакета).
- **Ясные имена:** Называйте экспортируемые функции и переменные понятно, чтобы избежать путаницы при импорте.
- **Ограничьте экспорты:** Экспортируйте только необходимое, чтобы минимизировать зависимости и улучшить читаемость.
- **Импортируйте в начале:** Размещайте `require()` в начале файла для предсказуемости и избежания ошибок из-за порядка выполнения.
- **Обработка ошибок:** Проверяйте наличие модуля, если путь динамический, например:

  ```javascript
  let module;
  try {
    module = require('./optionalModule');
  } catch (e) {
    console.error('Module not found');
  }
  ```
- **Переход на ESM:** В новых проектах или при рефакторинге переводите код на ES Modules, добавляя `"type": "module"` в `package.json` или используя `.mjs`. Для обратной совместимости используйте `require('esm')` или бандлеры.
- **Организация:** Группируйте связанные функции в одном модуле (например, `utils.js` для утилит). 

Используйте `index.js` для реэкспорта из папки:

  ```javascript
  // folder/index.js
  module.exports = {
    util1: require('./util1'),
    util2: require('./util2')
  };
  ```
- **Минимум побочных эффектов:** Избегайте изменения глобальных объектов (например, `global`) в модулях.

#### CommonJS vs. ES Modules:

- **Синтаксис:** CJS: `require`/`module.exports`, ESM: `import`/`export`.
- **Загрузка:** CJS синхронная, ESM асинхронная (поддерживает `import()`).
- **Tree-shaking:** CJS не поддерживает, ESM поддерживает.
- **Браузеры:** CJS требует бандлеров, ESM работает нативно с `type="module"`.
- **Совместимость:** CJS — стандарт Node.js, ESM — стандарт ECMAScript, поддерживается везде.

#### Пример миграции на ESM:

**CommonJS:**

```javascript
// math.js
module.exports = {
  add: (a, b) => a + b
};

// app.js
const { add } = require('./math');
```

**ESM:**

```javascript
// math.js
export const add = (a, b) => a + b;

// app.js
import { add } from './math.js';
```

**Для Node.js добавьте в `package.json`:**

```json
{ "type": "module" }
```

CommonJS остается актуальной для Node.js-проектов, но для новых разработок и браузерных приложений предпочтительнее ESM из-за стандартизации, оптимизаций и нативной поддержки.