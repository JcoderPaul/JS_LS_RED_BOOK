### IIFE в JavaScript

IIFE (Immediately Invoked Function Expression) — это функция-выражение, которая вызывается сразу после своего определения. Она позволяет создать изолированную область видимости (scope), чтобы избежать загрязнения глобального пространства имен, и часто использовалась до появления нативных модулей в ES6. 

IIFE — это паттерн, где функция оборачивается в круглые скобки для интерпретации как выражение, а затем сразу вызывается с помощью `()`.

#### Когда применяется:

IIFE применяется в сценариях, где нужно:
- Создать приватный scope для переменных и функций, чтобы они не попадали в глобальное пространство (global namespace pollution), особенно в старых проектах без модулей.
- Инициализировать код сразу после загрузки, например, для настройки конфигураций, инициализации библиотек (как jQuery) или создания singleton-объектов.
- Избежать конфликтов имен в скриптах, загружаемых в одном HTML-файле, или в legacy-коде без бандлеров.
- В комбинации с асинхронным кодом для создания closure (замыканий) и захвата переменных.
- В скриптах, загружаемых в браузере без модульной системы (до ES6), для организации кода в "псевдо-модули".
- В legacy-коде или когда модули (ESM/CommonJS) не используются, но нужна инкапсуляция.

В современных проектах IIFE менее актуален, поскольку ES Modules и стрелочные функции решают похожие задачи лучше. Не используйте IIFE в простых скриптах или когда доступны модули — это может усложнить код.

#### Как применяется:

IIFE создается как функция-выражение (function expression, не declaration), оборачивается в скобки `()` для принудительного вызова, и сразу инвоцируется с аргументами в `()`. 

Синтаксис:

```javascript
(function() {
  // Код внутри IIFE
})();
```

- Обертка в скобки `(function() { ... })` предотвращает парсинг как объявления функции (которое требует `function` в начале).
- Вызов `()` сразу после — делает её immediately invoked.
- Можно передавать аргументы: `(function(arg) { ... })(value);`.

Основные варианты:
- **Анонимная IIFE:** Без имени, для одноразового использования.
- **С именованной функцией:** Для отладки (стек вызовов показывает имя).
- **С аргументами:** Может принимать параметры, например, для передачи глобальных объектов вроде `window` или `jQuery`.
- **В strict mode:** Рекомендуется добавлять `'use strict';` внутри для предотвращения ошибок.

#### Примеры:

**Базовый пример: Изоляция переменной**

```javascript
// Без IIFE: загрязняет глобальный scope
var globalVar = 'global';

(function() {
  var localVar = 'local';  // Доступна только внутри IIFE
  console.log(localVar);   // 'local'
  console.log(globalVar);  // 'global' (доступ к внешнему scope)
})();

console.log(typeof localVar);  // undefined (не видна снаружи)
```

**Пример с аргументами: Модуль-подобная структура**

```javascript
var counter = (function(startValue) {
  var count = startValue;  // Приватная переменная
  
  return {
    increment: function() {
      count++;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
})(0);  // Передаем начальное значение 0

console.log(counter.increment());  // 1
console.log(counter.getCount());   // 1
// count недоступна снаружи
```

**Пример в браузере: Инициализация DOM**

```javascript
(function() {
  'use strict';
  
  function init() {
    var button = document.getElementById('myButton');
    if (button) {
      button.addEventListener('click', function() {
        alert('Clicked!');
      });
    }
  }
  
  // Вызов при загрузке
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
```

IIFE всегда возвращает результат функции (если есть `return`) и может экспортировать значения через замыкания или глобальные переменные.

#### Примеры:

**Базовый пример анонимной IIFE (создание приватной переменной):**

```javascript
(function() {
  var privateVar = 'Я приватная!';  // Не доступна извне
  console.log(privateVar);  // Вывод: Я приватная!
})();  // Сразу вызывается
console.log(typeof privateVar);  // undefined
```
Здесь IIFE создает scope, и `privateVar` не попадает в глобальный scope.

**IIFE с аргументами (передача jQuery):**

```javascript
(function($) {  // $ — это jQuery
  'use strict';
  $(document).ready(function() {
    $('#myElement').hide();  // Используем $ локально
  });
})(jQuery);  // Передаем jQuery как аргумент
```
Это предотвращает конфликты, если $ используется другой библиотекой.

**Именованная IIFE для отладки и возврата объекта (singleton):**

```javascript
var myModule = (function namedIIFE() {
  var counter = 0;  // Приватное состояние
  return {
    increment: function() {
      return ++counter;
    },
    getCounter: function() {
      return counter;
    }
  };
})();
console.log(myModule.increment());  // 1
console.log(myModule.getCounter());  // 1
console.log(myModule.increment());  // 2
```
Здесь IIFE возвращает объект с публичными методами, а `counter` остается приватным через closure.

**IIFE в цикле для захвата переменных (до ES6 let):**

```javascript
for (var i = 0; i < 3; i++) {
  (function(index) {  // IIFE захватывает текущий i
    setTimeout(function() {
      console.log(index);  // 0, 1, 2 (не 3,3,3 как без IIFE)
    }, 100);
  })(i);  // Передаем i как аргумент
}
```
Это решает проблему closure в циклах с `var`.

#### Особенности:

- **Scope и closure:** IIFE создает новую область видимости, переменные внутри — локальные. Замыкания позволяют "запоминать" значения для внешнего использования.
- **Strict mode по умолчанию:** В ES6+ IIFE в модулях strict, но в скриптах добавляйте вручную.
- **Одноразовый вызов:** Выполняется только раз при загрузке, кэшируется как модуль.
- **Асинхронность:** Не блокирует поток, но синхронна по природе. Для async используйте с Promise или async/await внутри.
- **Совместимость:** Работает везде (IE8+), но в браузерах без поддержки — оборачивайте в try-catch.
- **Один раз:** Функция выполняется только один раз при объявлении; нет повторных вызовов.
- **Побочные эффекты:** Может модифицировать глобальные объекты (например, добавлять методы в прототипы), но это не рекомендуется.
- **Альтернативы:** В ES6+ заменяется блоками `{ let x = 1; }` для блочной области видимости или стрелочными функциями: `(() => { ... })();`.
- **Ограничения:** Не подходит для реэкспорта (в отличие от модулей). В Node.js с ESM IIFE не нужен, так как модули изолированы по умолчанию.
- **Минусы:** Может усложнить отладку (анонимные вызовы), и в больших проектах лучше заменить на модули. Не поддерживает tree shaking в бандлерах.

#### Best practices
- **Используйте с аргументами для globals:** Передавайте `window`, `document` или библиотеки, чтобы избежать зависимости от глобального scope.
- **Добавляйте strict mode:** Всегда `'use strict';` в начале IIFE для безопасности.
- **Именуйте для отладки:** В production — анонимно, в dev — с именем для лучшего стека ошибок.
- **Возвращайте объект:** Для модульного паттерна (Revealing Module Pattern) возвращайте публичный API, скрывая приватные части.
- **Предпочитайте модули:** В новых проектах мигрируйте на ES Modules или CommonJS вместо IIFE. Используйте IIFE только для legacy или быстрого прототипа.
- **Избегайте вложенности:** Не вкладывайте IIFE друг в друга без необходимости — это снижает читаемость. Тестируйте на утечки памяти в closure.
- **В бандлерах:** Webpack/Rollup оптимизируют IIFE, но для ES6+ используйте import/export для лучшей производительности.
- **Тестирование:** IIFE сложно тестировать из-за приватности; используйте публичный API (возвращаемый объект).
- **Производительность:** IIFE не влияет на perf, но в больших скриптах лучше разбивать на модули для lazy loading.
- **Современный синтаксис:** Для ES6+ используйте стрелочные IIFE: `(() => { console.log('IIFE'); })();` — короче и без `this`-проблем.